package tlsrecord

import (
	"crypto/tls"
	"fmt"

	"golang.org/x/crypto/cryptobyte"
)

type ProtocolVersion uint16

func (p ProtocolVersion) String() string {
	switch p {
	case tls.VersionSSL30:
		return "SSL 3.0"
	case tls.VersionTLS10:
		return "TLS 1.0"
	case tls.VersionTLS11:
		return "TLS 1.1"
	case tls.VersionTLS12:
		return "TLS 1.2"
	case tls.VersionTLS13:
		return "TLS 1.3"
	default:
		return "unknown"
	}
}

//	enum {
//		invalid(0),
//		change_cipher_spec(20),
//		alert(21),
//		handshake(22),
//		application_data(23),
//		heartbeat(24),  /* RFC 6520 */
//		(255)
//	} ContentType;
type ContentType uint8

const (
	ContentTypeInvalid          ContentType = 0
	ContentTypeChangeCipherSpec ContentType = 20
	ContentTypeAlert            ContentType = 21
	ContentTypeHandshake        ContentType = 22
	ContentTypeApplicationData  ContentType = 23
	ContentTypeHeartbeat        ContentType = 24 /* RFC 6520 */
)

func (c ContentType) String() string {
	switch c {
	case ContentTypeInvalid:
		return "Invalid"
	case ContentTypeChangeCipherSpec:
		return "Change Cipher Spec"
	case ContentTypeAlert:
		return "Alert"
	case ContentTypeHandshake:
		return "Handshake"
	case ContentTypeApplicationData:
		return "Application Data"
	case ContentTypeHeartbeat:
		return "Heartbeat"
	}
	return "unknown"
}

//	struct {
//		ContentType type;
//		ProtocolVersion legacy_record_version;
//		uint16 length;
//		opaque fragment[TLSPlaintext.length];
//	} TLSPlaintext;
type TLSPlaintext struct {
	// The higher-level protocol used to process the enclosed fragment.
	Type ContentType `json:"type"`
	// MUST be set to 0x0303 for all records
	// generated by a TLS 1.3 implementation other than an initial
	// ClientHello (i.e., one not generated after a HelloRetryRequest),
	// where it MAY also be 0x0301 for compatibility purposes.  This
	// field is deprecated and MUST be ignored for all purposes.
	// Previous versions of TLS would use other values in this field
	// under some circumstances.
	LegacyRecordVersion ProtocolVersion `json:"legacy_record_version"`
	// The length (in bytes) of the following
	// TLSPlaintext.fragment.  The length MUST NOT exceed 2^14 bytes.  An
	// endpoint that receives a record that exceeds this length MUST
	// terminate the connection with a "record_overflow" alert.
	Length uint16 `json:"length"`
	// The data being transmitted.  This value is transparent and
	// is treated as an independent block to be dealt with by the higher-
	// level protocol specified by the type field.
	Fragment []byte `json:"-"`
}

func (t *TLSPlaintext) String() string {
	return fmt.Sprintf("%s %s %d", t.Type, t.LegacyRecordVersion, t.Length)
}

// struct {
// 	opaque content[TLSPlaintext.length];
// 	ContentType type;
// 	uint8 zeros[length_of_padding];
// } TLSInnerPlaintext;

type TLSInnerPlaintext struct {
	// The TLSPlaintext.fragment value, containing the byte
	// encoding of a handshake or an alert message, or the raw bytes of
	// the application's data to send.
	Content []byte
	// The TLSPlaintext.type value containing the content type of the record.
	Type ContentType
	// An arbitrary-length run of zero-valued bytes may appear in
	// the cleartext after the type field.  This provides an opportunity
	// for senders to pad any TLS record by a chosen amount as long as
	// the total stays within record size limits.  See Section 5.4 for
	// more details.
	Zeros []byte
}

//	struct {
//		ContentType opaque_type = application_data; /* 23 */
//		ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
//		uint16 length;
//		opaque encrypted_record[TLSCiphertext.length];
//	} TLSCiphertext;
type TLSCiphertext struct {
	// The outer opaque_type field of a TLSCiphertext record
	// is always set to the value 23 (application_data) for outward
	// compatibility with middleboxes accustomed to parsing previous
	// versions of TLS.  The actual content type of the record is found
	// in TLSInnerPlaintext.type after decryption.
	OpaqueType ContentType `default:"ContentTypeApplicationData" json:"opaque_type"`
	// The legacy_record_version field is always
	// 0x0303.  TLS 1.3 TLSCiphertexts are not generated until after
	// TLS 1.3 has been negotiated, so there are no historical
	// compatibility concerns where other values might be received.  Note
	// that the handshake protocol, including the ClientHello and
	// ServerHello messages, authenticates the protocol version, so this
	// value is redundant.
	LegacyRecordVersion ProtocolVersion `default:"tls.VersionTLS12" json:"legacy_record_version"`
	// The length (in bytes) of the following
	// TLSCiphertext.encrypted_record, which is the sum of the lengths of
	// the content and the padding, plus one for the inner content type,
	// plus any expansion added by the AEAD algorithm.  The length
	// MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a
	// record that exceeds this length MUST terminate the connection with
	// a "record_overflow" alert.
	Length uint16 `json:"length"`
	// The AEAD-encrypted form of the serialized TLSInnerPlaintext structure.
	EncryptedRecord []byte `json:"encrypted_record"`
}

func UnmarshalPlaintext(data []byte) (*TLSPlaintext, error) {
	record := &TLSPlaintext{}

	msg := cryptobyte.String(data)
	if !msg.ReadUint8((*uint8)(&record.Type)) {
		return nil, fmt.Errorf("failed to read 'type' %s", record)
	}
	if !msg.ReadUint16((*uint16)(&record.LegacyRecordVersion)) {
		return nil, fmt.Errorf("failed to read 'legacy_record_version' %s", record)
	}
	if !msg.ReadUint16((*uint16)(&record.Length)) {
		return nil, fmt.Errorf("failed to read 'length' %s", record)
	}
	if !msg.ReadBytes(&record.Fragment, int(record.Length)) {
		return nil, fmt.Errorf("failed to read 'fragment' %s", record)
	}
	if !msg.Empty() {
		fmt.Printf("tls no empty\n")
	}
	return record, nil
}

func Tes(x int) *TLSPlaintext {
	a := &TLSPlaintext{}
	a.Type = ContentTypeInvalid
	a.LegacyRecordVersion = tls.VersionTLS13
	return a
}
